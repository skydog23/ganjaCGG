///////////////////////////////////////////////////////////////////
// a Ganja.js notebook on Log and Exp in 3DPGA
///////////////////////////////////////////////////////////////////

notebook();

///////////////////////////////////////////////////////////////////
// Introduction text. 
///////////////////////////////////////////////////////////////////

md(`
# Log and Exp in $\\mathbb R_{3,0,1}$

---

## Cheat Sheet

Just here for results? Please be served (code is at the bottom):

| Name | Formula |
|------|---------|
| Invariant Factorisation of motor $M = RT = TR$ | $T = 1 + \\cfrac {\\langle M\\rangle_4}{\\langle M \\rangle_2} \\quad \\quad R = MT^{-1}$
| Invariant split of bivector $B$ into commuting simple $B_1, B_2$ | $B_1 = \\cfrac {B \\wedge B}{2B} \\quad \\quad B_2 = B - B_1$
| Exponential of simple bivector $B$ | $e^{\\alpha B} = \\mathbf c(\\alpha B) + \\mathbf s(\\alpha B)$
| $\\mathbf c(\\alpha B)$ | $\\cos \\alpha \\quad \\text{iff} \\quad B^2 = -1  $ |
|                         | $1 \\quad \\\\, \\\\, \\\\, \\\\, \\quad \\text{iff} \\quad B^2 = 0  $ |
| $\\mathbf s(\\alpha B)$ | $B \\sin \\alpha  \\\\,\\\\, \\text{iff} \\quad B^2 = -1  $ |
|                         | $B \\quad \\\\, \\\\, \\\\, \\quad \\text{iff} \\quad B^2 = 0  $ |
## Terms & Notation

Geometric algebra uses quite a few terms to describe the various elements that represent
transformations. Lets start with a short overview to help you navigate the literature.

| Name          | Meaning                                   | Notation
|---------------|-------------------------------------------|--
| Spinor        | General element of the even subalgebra    | $s \\in \\mathbb R^+_{p,q,r}$
| Versor        | Product of invertible vectors             | $\\prod \\vec v,\\quad \\vec v^2 \\neq 0$
| Rotor         | Normalized, even, grade preserving versor | $R \\in \\mathbb R^+_{p,q,r}, R \\tilde R = 1$
| Motor         | Composition of rotations and translations | $\\prod e^B, B^2 \\in [0,-1] $
| $k$-reflection| Composition of k reflections.             | $\\prod_k \\vec v,\\quad \\vec v^2 = 1 $

For our purposes, the important group of distance preserving transformations, also called
the **isometries**, is exactly the set of $k$-reflections. The even or $2k$-reflections are
continuous, and for them we can define logarithmic and exponential functions.
---
## Bireflections $ab$

Let us first look at the 2-reflections or *bireflections*. These are the compositions of two reflections in
planes, and form the rotations (when the planes intersect) and the translations (when the
planes are parallel). 
`)

///////////////////////////////////////////////////////////////////
// Rotations and Translations Graph
///////////////////////////////////////////////////////////////////

Algebra(3,0,1,()=>{

  var basePlane = [...Array(4)]
        .map((x,i)=>!(('0'+([0,1,3,2][i]).toString(2)).slice(-2).split('').map(x=>2*(x-0.5))*[1e1,1e2]+1e0))
 
  var plane = (pos, plane)=>{
    var PN = plane.Normalized;
    var mot = (1+pos/!1e0).Normalized * (1 + PN/(1e3-PN.e0*.5e0)).Normalized;
    return mot>>>basePlane
  }
  
  var box = [...Array(8)].map((x,i)=>('000'+i.toString(2)).slice(-3))
            .map(x=>x.split('').map(x=>0.5*(x-0.5)))
            .map(x=>!(1e0+x*[1e1,1e2,1e3]));
            
  var boxl = box.map((a,i)=>box.map((b,j)=>(i<=j||(i^j)&(i^j-1))?0:[a,b])).flat().filter(x=>x);

  boxl = (1-0.25e03)>>>boxl;

  var c = this.graph(()=>{
    
    var t = performance.now()/1000;
    
    var p1 = 1e1+(1+Math.sin(t))*.3e3,
        p2 = 1e1-(1+Math.sin(t))*.3e3;
    
    var p3 = 1e1+(1+Math.sin(t))*.3e0,
        p4 = 1e1-(1+Math.sin(t))*.3e0;

    
    return [
      0x009879,
      `<G fill-opacity="0.2" stroke="#009879" stroke-width="0.02" stroke-opacity="1">`,
      plane(!(1e0-2e1),p1,2),
      plane(!(1e0-2e1),p2,2),
      plane(!(1e0+2e1),p3,2),
      plane(!(1e0+2e1),p4,2),
      0x008099,
      ...(1+1e01) >>> boxl,
      ...(1+1e01)*p2*p1 >>> boxl,
      ...(1-1e01) >>> boxl,
      ...(1-1e01)*p3*p4 >>> boxl,
      `</G>`,
      0x009879,
      (1+1e01)>>>1e13,
    ]
  
    
    
  },{animate:1,p:-0.2,clip:4,lineWidth:8});
  
  c.style.background = 'white';
  c.style.width = '100%';
  c.style.height = '300px';
  c.onwheel = undefined;
  
  return c;
  
});

///////////////////////////////////////////////////////////////////
// Introduction text. 
///////////////////////////////////////////////////////////////////

md(`

### Exponential form of a bireflection

The bireflections all represent a so called one-parameter family of transformations.
(generated by varying the *separation*, i.e. angle or distance between the reflections,
while keeping their intersection line fixed). This family of transformations can be
written in a generalized exponential form:

$$ e^{\\alpha \\overline B} = \\mathbf c(\\alpha \\overline B) + \\mathbf s(\\alpha \\overline B) $$

Where $\\mathbf c$ and $\\mathbf s$ are generalized cosine and sine functions that take
any bivector $B = \\alpha \\overline B$ as argument (the overline here is used to denote normalisation).
The $\\mathbf c$ function produces a scalar, while the $\\mathbf s$ function produces a bivector.

$$ \\mathbf c(\\alpha \\overline B) = \\begin{cases} 1 &\\overline B^2 = 0 \\\\\\\\
\\cos\\alpha &\\overline B^2 = -1 \\\\\\\\ 
\\cosh\\alpha &\\overline B^2 = 1
\\end{cases} $$

$$ \\mathbf s(\\alpha \\overline B) = \\overline B\\begin{cases} 1 &\\overline B^2 = 0 \\\\\\\\
\\sin\\alpha &\\overline B^2 = -1 \\\\\\\\ 
\\sinh\\alpha &\\overline B^2 = 1
\\end{cases} $$

These allow us to easily parametrize any rotation/translation/boost with angle/distance $\\alpha$
around line $\\overline B$ as $e^{-\\frac \\alpha 2 \\overline B}$

Note, however, that not all bivectors $B$ are lines, and the above formulas work only
when $B \\wedge B = 0$, the condition for $B$ to be a line. The bivectors
that do not meet this condition can still be exponentiated, but they instead will generate
quadreflections.

### Logarithm of a bireflection

From the formulas above, the (principal) logarithms of bireflections are :

$$ \\log R = \\begin{cases} \\langle R \\rangle_2 &\\iff {\\langle R\\rangle_2}^2 = 0\\\\\\\\
\\overline {\\langle R \\rangle_2} \\cos^{-1}\\langle R \\rangle_0  &\\iff {\\langle R \\rangle_2}^2<0\\end{cases}$$

---
## Quadreflections
`)

///////////////////////////////////////////////////////////////////
// Rotations and Translations Graph
///////////////////////////////////////////////////////////////////

Algebra(3,0,1,()=>{

  var basePlane = [...Array(4)].map((x,i)=>!(('0'+([0,1,3,2][i]).toString(2)).slice(-2).split('').map(x=>2*(x-0.5))*[1e1,1e2]+1e0) )
 
  var plane = (pos, plane)=>{
    var PN = plane.Normalized;
    var mot = (1+pos/!1e0).Normalized * (1 + PN/(1e3-PN.e0*.5e0)).Normalized;
    return mot>>>basePlane
  }
  
  var box = [...Array(8)].map((x,i)=>('000'+i.toString(2)).slice(-3))
            .map(x=>x.split('').map(x=>0.5*(x-0.5)))
            .map(x=>!(1e0+x*[1e1,1e2,1e3]));
            
  var boxl = box.map((a,i)=>box.map((b,j)=>(i<=j||(i^j)&(i^j-1))?0:[a,b])).flat().filter(x=>x);

 // boxl = (1-0.25e03)>>>boxl;

  var c = this.graph(()=>{
    
    var t = performance.now()/1000;
    
    var p1 = 1e1+(1+Math.sin(t))*.15e3,
        p2 = 1e1-(1+Math.sin(t))*.15e3;
    
    var p3 = 1e2+(1+Math.sin(t))*.15e0,
        p4 = 1e2-(1+Math.sin(t))*.15e0;

    
    return [
      0x009879,
      `<G fill-opacity="0.2" stroke="#009879" stroke-width="0.02" stroke-opacity="1">`,
      plane(!(1e0),p1),
      plane(!(1e0),p2),
      plane(!(1e0),p3),
      plane(!(1e0),p4),
      0x008099,
      ...(1+0e01) >>> boxl,
      ...(1+0e01)*p4*p3*p2*p1 >>> boxl,
      `</G>`,
      0x009879,
      (1+0e01)>>>1e13,
    ]
  
    
    
  },{animate:1,p:-0.2,clip:4,lineWidth:8});
  
  c.style.background = 'white';
  c.style.width = '100%';
  c.style.height = '300px';
  c.onwheel = undefined;
  
  return c;
  
});



md(`
A general combination of four reflections produces a so called *screw motion*. A motor $M$ is a
screw motion when its quadvector part is non-zero. $\\langle M \\rangle_4 \\neq 0$. Its associated
bivector logarithm will be non-simple. To calculate the logarithm of such a motor, or equivalently
the exponential of a non-simple bivector, we aim to use the following exponential identity

$$ e^{B_1+B_2} = e^{B_1}e^{B_2} = e^{B_2}e^{B_1} \\quad \\iff B_1B_2=B_2B_1 $$

Our goal is now to factorize our quadreflection into two commuting bireflections (for the logarithmic map),
or to split our non-simple bivector into two simple ones (for the exponential map).

### Factorizing a quad reflection

To factorize our general quadreflection $M$, we use the insight by Chasles and Mozi that any general
screw motion can be seen as a translation along and a rotation around the same line. We take the ansatz
that this decomposition of $M$ into a commuting translation $T$ and rotation $R$ exists:

$$ M = TR = RT$$

We know from above that all translations and rotations are simple, and that we can write them in 
their exponential form:

$$\\begin{aligned} M &= TR \\\\\\\\
&= e^{\\alpha B_1} e^{\\beta B_2} \\\\\\\\
&= (1 + \\alpha B_1)(\\cos \\beta + \\sin \\beta B_2) \\\\\\\\
&= \\cos \\beta + \\color{red} \\sin \\beta B_2 + \\alpha \\cos \\beta B_1 \\color{black} + \\alpha \\sin \\beta B_1 B_2 \\\\\\\\
&= \\langle M \\rangle_0 + \\color{red} \\langle M \\rangle_2 \\color{black} + \\langle M \\rangle_4
\\end{aligned}$$

Now remembering that $ {B_1}^2 = 0$ we note that that 
$\\langle T\\rangle_2 \\langle M \\rangle_2 = \\langle M \\rangle_4$ and thus:

$$\\begin{aligned}
\\langle T \\rangle_2 \\langle M \\rangle_2 &= \\alpha B_1 (\\sin \\beta B_2 + \\alpha \\cos \\beta B_1) = \\alpha \\sin \\beta B_1B_2 = \\langle M \\rangle_4 \\\\\\\\
\\iff \\langle T \\rangle_2 &= \\frac {\\langle M \\rangle_4} {\\langle M \\rangle_2},
\\end{aligned}$$

enabling us to calculate the translation:

$$\\begin{aligned}
T &= 1 + \\langle T \\rangle_2 =1+\\frac {\\langle M \\rangle_4} {\\langle M \\rangle_2} \\\\\\\\
R &= MT^{-1}
\\end{aligned}$$

This completes our factorisation in commuting $T$ and $R$ and trivializes the calculation of the
logarithm of our general quadreflection.

$$ \\begin{aligned} \\log M &= \\log T + \\log R \\\\\\\\
   \\log T &= \\langle T \\rangle_2 \\\\\\\\
   \\log R &=\\overline{\\langle R \\rangle_2}\\cos^{-1}\\langle R \\rangle_0  \\end{aligned} $$

### Inverting a general bivector.

The formula above requires us to invert a general 3D PGA bivector. We remind the reader that the
squared norm of a bivector is given by : 

$$ n_B = B\\tilde B $$

For a simple bivector this is a scalar, making the inverse trivial $\\frac {\\tilde B} {n_B}$. For a general bivector, this is 
a so called *Study Number*, consisting out of a scalar and pseudoscalar part.

$$ n_B = \\langle n_B \\rangle_0 + \\langle n_B \\rangle_4 $$

These Study numbers are still easy to invert, for this we define its Study conjugate :

$$ \\widetilde {n_B} = \\langle n_B \\rangle_0 - \\langle n_B \\rangle_4$$ 

The product of a Study number and its conjugate is always scalar, which allows us to write the inverse of our bivector $B$ as

$$ B^{-1} = \\tilde B \\cfrac {\\widetilde {n_B}} {n_B \\widetilde {n_B}}  $$ 

### Splitting a non-simple bivector.

We assume that a decomposition of $B$ into two commuting simple bivectors exists, and
furthermore that one of these bivectors is a pure translation bivector that squares to zero.

$$ B = B_1 + B_2 $$

Using the commutativity and orthogonality of $B_1, B_2$ we can calculate $B \\wedge B$

$$B \\wedge B = (B_1 + B_2) \\wedge (B_1 + B_2) = B_1 \\wedge B_2 + B_2 \\wedge B_1 = 2B_1 \\wedge B_2 = 2B_1B_2
$$

Dividing by $2B$ and using $ {B_1}^2 = 0$ now gives us

$$ \\cfrac {B \\wedge B} {2B} = \\cfrac {B_1B_2} {B_1+B_2}  = \\cfrac {{B_1}^2 + B_1B_2 } {B_1+B_2}  = \\cfrac {B_1(B_1 + B_2)} {B_1+B_2} =  B_1
$$

Which gives us the translation bivector, and makes the calculation of $B_2$ trivial:

$$ B_2 = B - B_1 $$

---

## The Cayley map

The exponential map is not the only map that maps between motors and bivectors. Another popular choice
is the Cayley map. It is defined as

$$ C(R) = \\cfrac {1-R} {1+R} $$

This map is its own inverse - give it a motor and it gives you a bivector, give it a bivector
and it gives you a motor. It is easy to calculate, but unlike the exponential map it is not
linear. For bireflections it is not hard to demonstrate that

$$ e^{B\\alpha} = C(B \\tan \\frac \\alpha 2) $$

To get a sense of the difference, the following graph shows what regular spaced bivectors look
like under both the exponential (left) and Cayley maps (right)


`)

Algebra(2,0,1,()=>{
  
  const {E,PI,atan,tan} = Math;
  
  var C = x=>(1-x)/(1+x);
  
  var exp = [...Array(64)].map((x,i)=>E**(i/64*PI*1e12)>>>!(1e0+1.5e1))
            .map(x=>[!1e0,x])

  var cay = [...Array(64)].map((x,i)=>C(i/64*PI*1e12)>>>!(1e0+1.5e1))
            .map(x=>[!1e0,x])
  
  
  var c = this.graph(
                [0x009879,...(1-1e01)>>>cay, ...(1+1e01)>>>exp],
                {lineWidth:2}
               );
  
  c.style.background = 'white';
  c.style.width = '100%';
  c.onwheel = undefined;
  
  return c;
})

md(`---

## Programmer overview

For those that are more comfortable reading code.

### Invariant Split 
\`\`\`
// Returns commuting [rotation bivector, translation bivector]
function split(B) {
  if (B*B == 0) return [0, B]   // Pure translation.
  var b2 = (B ^ B) / (2 * B);   // Translation part
  var b1 = B - b2;              // Rotation part
  return [b1,b2];
}
\`\`\`

### Invariant Factorisation

\`\`\`
// Returns commuting [rotation bireflection, translation bireflection]
function factorise(R) {
  if (R.Grade(4) == 0) return (R.s == 1) ? [1, R] : [R, 1];
  var tran = 1 + R.Grade(4) / R.Grade(2);
  var rot  = R * ~tran;
  return [rot,tran];
}
\`\`\`

### Logarithm of a PGA motor

\`\`\`
function log(R) {
  var [rot, tran] = factorise(R);
  return tran.Grade(2) + rot.Grade(2).Normalized * Math.acos(rot.s);
}  
\`\`\`

### Exponential of a general PGA bivector

\`\`\`
function exp(B) {
  var [rotbv, tranbv] = split(B);
  var l = rotbv.Length;
  return (Math.cos(l) + Math.sin(l) * rotbv.Normalized) * (1 + tranbv);
}
\`\`\`
`)


