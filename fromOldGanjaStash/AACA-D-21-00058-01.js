Algebra(3,0,1,()=>{
  var point = (x,y,z,w)=>w*1e123 - x*1e023 + y*1e013 - z*1e012;
  var plane = (a,b,c,d)=>d*1e0 + a*1e1 + b*1e2 + c*1e3;
  var {sin, cos, E, PI, sign} = Math;
  
  // create a curve from an array of points
  // that is produce an array of segments
  var makeCurve = (cv, closed=true) => {
    let ret = cv.map((x,i,ar)=>{
      let ii = (i+1)%ar.length;
      return [x, ar[ii]]
    });
    return closed ? ret : ret.slice(0,-1)};

  // same for a surface, producing an array of quads
  var makeSurf = (arr, cl1=true, cl2=true) =>{
    let surf = arr.map((x,i,ar)=>{
      let ii = (i+1)%ar.length; 
      let reti = ar.map((y,j,ar2)=>{
        let jj = (j+1)%ar2.length; 
        return [ar[i][j], ar[ii][j], ar[ii][jj],ar[i][jj]];
      });
      return cl2 ? reti : reti.slice(0,-1);
    });
    return cl1 ? surf : surf.slice(0,-1);
    };

  var num = 99;    // number of sample points
  // ******************
  // This controls which example is shown
  // *******************
  var fig4 = false;

  // *****************************
  // ****   Example 1 ************
  // *****************************
  // This example implements Fig. 4 on p. 11 in EPGA
  // two 1-vector (plane) pencils, one around the z-axis, the other around the y-axis
  var zplane = [...Array(num)].map((x,i)=>plane(cos(i/num*2*PI),sin(i/num*2*PI),0,0));
  var yplane = [...Array(num)].map((x,i)=>plane(cos(i/num*2*PI), 0, sin(i/num*2*PI),0));
  // a rotation curve generated by product of the two reflection curves
  var qcurve = [...Array(num)].map((x,i)=>yplane[i] * zplane[i]);
  var axiscurve = qcurve.map((x,i)=> 1e123+x^1e0);

  var V = point(1,0,0,1);   // follow the unit x-vector 
  var vcurve = qcurve.map((x)=> (x >>> V).Grade(3));
  // to visualize the plane pencils, polarize and visualize the resulting ideal points
  var zcurve = zplane.map((x)=> (1e123 + x*1e0123).Grade(3));
  var ycurve = yplane.map((x)=> (1e123 + x*1e0123).Grade(3));
  // the display list for this example
  var graphicsFig4 = [
    0x0,"Figure 4, p. 11, AACA-D-21-00058",    
            "Produced using quaternion subalgebra of 3D EPGA",
    0x0, ...makeCurve(vcurve),
    0xff0000, ...makeCurve(zcurve),
    0x0000ff, ...makeCurve(ycurve),
    // 0x00ff00, ...makeCurve(axiscurve),
  ];
  
  // *****************************
  // ****   Example 2 ************
  // *****************************
  // This example shows a similar case to Fig. 6 on p. 15:
  // Generating a surface by sweeping a curve out by a one-parameter family of 
  // dual quaternions (realized as elements of the rotor group of EPGA)
  num = 49;
  var pt1 = 1e123 + 1e013,  // two points on the y-axis
      pt2 = 1e123 - 1e013;
  // wcurve is the curve we will sweep out: in this case, just line segment
  // perpendicular to the axis of the screw motion
  var wcurve =  [1e123 + 1e032, 1e123, 1e123-1e032]; // [...Array(num)].map((x,i)=>point(1+.5*cos(i/num*2*PI),0,.5*sin(i/num*2*PI),1));
    
  var canvas=document.body.appendChild(this.graph(
      ()=>{
        // Example 2 is calculated here since it changes when the user
        // drags one of the points pt1 or pt2, hence has to
        // be recomputed.
        var axis = [pt1, pt2];
        // B is the y-axis (vertical) plus its polar line (horizon line)
        var B = .5*(pt1 & pt2 + !(pt1&pt2));  
        // generate a curve dual quaternions that give the screw motion around B
        var dqcurve =  [...Array(num)].map((x,i)=> E**(((i/num)-.5)*B) );
        // apply this curve of DQs to the points of wcurve to generate a 2D array
        var dqpresurf = dqcurve.map((dq)=> wcurve.map( (pt) => (dq >>> pt).Grade(3)));
        // console.log("preSurf = ",dqpresurf);
        // process this 2D array to create an array of quadrilaterals
        var dqsurf = dqpresurf.map( (x,i,ar)=>makeCurve(x, false)).flat(1);
        // var dqsurf = makeSurf(dqpresurf, false, false).flat(1);
        console.log("dqsurf = ",dqsurf);
        var graphicsFig6 = [
            0x0,"Produced using dual quaternion subalgebra of EPGA",
            "Can be used to reproduce Fig. 6, p. 15,  AACA-D-21-00058",
            0x0, pt1, pt2,
            0x008888, ...dqsurf,
            0x0, ...makeCurve(wcurve, false), 
            0x880000, axis
  ];

         // return the elements we want graphed
         return [
            ...(fig4 ? graphicsFig4 : graphicsFig6)
        ]
      },      
      {animate:false,grid:true,pointRadius:1,lineWidth:2}
  ))
  canvas.style.backgroundColor = "white"
})
